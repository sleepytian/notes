[toc]

# 知识回顾

数据结构分为三个部分:

-   数据的逻辑结构
    -   线性结构 数据元素是一对一的关系
        -   线性表
        -   栈
        -   队列
        -   字符串, 数组, 广义表
    -   非线性结构 数据元素之间有一对多或者多对多的关系
        -   树形结构
        -   图形结构
-   数据的存储结构
    -   顺序存储
    -   链式存储
-   数据的运算
    -   检索, 排序, 插入, 删除, 修改等.

# 第二章 线性表

## 2.1. 线性表的定义和特点

### 线性表

由m(n>=0)个数据元素(节点)a1, a2 ... an 组成的有限序列.

>   a_1, a_2, ... a_n 后面的表示下标, 后面会用 ^ 表示上标.

-   其中数据元素的个数n定义为表的长度.
-   当n=0时叫做空表
-   将费控的线性表(n>0)记作: (a_1, a_2 ... a_n)
-   这里的数据元素a_i只是一个抽象的符号, 具体含义在不同情况下可以不同.

**同一个线性表中的元素必定具有相同特性, 数据元素间的关系是线性关系**.

### 线性表的逻辑特征

-   在非空线性表中, 有且只有一个开始节点, 他没有直接前驱, 并且有且只有一个直接后继.
-   有且只有一个终端节点, 没有直接后继, 只有一个直接前驱.
-   其余的内部节点都有且只有一个直接前驱和一个直接后继.

**线性表是一种典型的线性结构**.

## 2.2. 案例引入

### 案例1 一元多项式的运算

一元多项式的运算中, 每一项的系数的组合可以作为一个线性表存储.

这个线性表可以使用数组实现.

**对于稀疏多项式**改如何处理?

稀疏多项式很多项都没有系数, 如果使用线性表, 将会导致大量内存浪费. 这种情况下, 可以只记录系数不为零的项. (比如使用结构体+链表的方式实现)

### 案例2 图书信息管理

图书表可以抽象为一个线性表, 表中每本图书抽象为线性表中的一个数据元素.

### 总结

上述案例都可以使用线性表解决.

-   线性表中数据元素的类型可以是简单类型, 也可以是复杂类型. (基本类型和复合类型)
-   许多实际应用问题所涉及的基本操作有很大的相似性, 不应该为每一个具体应用单独编写一个程序.
-   从具体应用中抽象出共性的**逻辑结构和基本操作**(抽象数据类型), 然后实现其存储结构和基本操作.

## 2.3. 线性表的类型定义

这里的**类型**指的是抽象数据类型. 是从实际问题中抽象出来的数据模型及其操作.

定义线性表, 就要定义线性表及其具体操作.

抽象数据类型的定义有固定的格式: 数据对象, 关系集合, 基本操作. 下面是线性表的抽象数据类型.

```text
ADT List {
	数据对象: D = {a_i | a_i 属于 Elemset, i = 1, 2, ... n, n >= 0}
	数据关系: R = {<a_(i-1), a_i> | a_(i-1), a_i 属于D (i = 1,2,3...n)}
	基本操作:
		InitList(&L);
		DestoryList(&L);
		ListInsert(&L, i, e);
		ListDelete(&L, i, &e);
		...
} ADT List
```

下面是具体的实现方式:

### 基本操作1

-   InitList(&L)

    操作结果: 构造一个空的线性表.

-   DestoryList(&L)

    -   初始条件: 线性表L已经存在.
    -   操作结果: 销毁线性表L本身.

-   ClearList(&L)

    -   初始条件: 线性表L已存在.
    -   操作结果: 将线性表L重置为空表.

### 基本操作2

-   ListEmpty(L)

    -   初始条件: 线性表L已存在.

    -   操作结果: 若线性表为空, 返回true, 否则返回false.

-   ListLength(L)

    -   初始条件: 线性表L已存在.
    -   操作结果: 返回线性表L中的数据元素个数.

### 基本操作3

-   GetElem(L, i, &e)
    -   初始条件: 线性表L已存在, 1 <= i <= ListLength(L);
    -   用e返回线性表L中的第i个元素的值.
-   LocateElem(L, e, conpare() )
    -   初始条件: 线性表L已存在, compare()是数据元素判定函数,
    -   操作结果: 返回L中第1个与e满足compare()的数据元素的位序. 若这样的数据元素不存在则返回0.

### 基本操作4

-   PriorElem(L, cur_e, &pre_e) *获得元素的直接前驱* 
    -   初始条件: 线性表L已经存在.
    -   操作结果: 若cur_e是L的数据元素, 且不是第一个元素, 则用 pre_e 返回他的前驱元素, 否则操作失败, pre_e 没有意义.
-   NextElem(L, cur_e, &next_e)
    -   初始条件: 线性表L已经存在.
    -   操作结果: 如果cur_e是L的数据元素, 且不是最后一个元素, 则用 next_e 返回他的后继元素, 否则操作失败, next_e 没有意义.

### 基本操作5,6

-   ListInsert(&L, i, e)
    -   初始条件: 线性表L已经存在. 1<= i <= ListLength(L) + 1;
    -   操作结果: 在L的第i个位置之前插入一个新的数据元素e,  L的长度+1
-   ListDelete(&L, i, &e)
    -   初始条件: 线性表L已经存在. 1<= i <= ListLength(L) + 1.
    -   操作结果: 删除L的第i个数据元素, 并用e返回其值, L的长度-1.
-   ListTraverse(&L, visited() ) *遍历表中全部元素并且对其执行函数visited()* 
    -   初始条件: 线性表L已经存在.
    -   操作结果: 一次对线性表中每个元素调用visited().

### 操作总结

-   以上所提及的运算是逻辑结构上定义的运算. 只要给出这些运算的功能是"做什么", 至于"如何做"等实现细节, 只有待确定了存储结构之后才考虑.
-   具体实现将在接下来的课程中实现.

## 2.4. 线性表的顺序表示和实现

-   在计算机内, 线性表有两种基本的存储结构: 顺序存储结构和练市存储结构.

本节介绍线性表的顺序存储结构的表示和实现.

线性表的顺序表又称为**顺序存储结构**或者**顺序映像**.

**顺序存储定义**: 把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构,

