[toc]

# 第一周笔记

## 1.4. 算法和算法分析(1)

### 数据结构与算法的研究内容

-   研究对象的特性及其相互间的关系 -- 逻辑结构
-   有效的组织计算机存储 -- 存储结构
-   有效的实现对象之间的运算关系 -- 算法

### 算法的定义

-   对特定问题求解方法和步骤的一种描述, 是指令的有限序列, 其中每一个指令表示一个或者多个操作.

### 算法的描述

-   自然语言
-   流程图(传统流程图/ns流程图)
-   伪代码/类语言(类C语言)
-   程序代码

### 算法和程序

-   算法是解决问题的一种方法或者过程, 考虑如何将输入变成输出. 一个问题可以有多种算法.
-   程序使用某种程序设计语言对算法的具体实现.

**程序 = 数据结构 + 算法** 

-   数据结构通过算法实现.
-   算法根据数据结构设计程序.

### 算法的特型

一个算法必须具备以下五个特性:

1.   有穷性. 有穷步数, 每一步都在有穷时间内完成.
2.   确定性. 每条指令没有二义性, 相同的输入获取相同的输出.
3.   可行性. 算法是可执行的, 算法描述的操作可以用以实现的基本操作执行有限次实现.
4.   输入. 一个算法有零个或者多个输入.
5.   输出. 一个算法应该有一个或者多个输出.

### 算法设计的要求

-   正确性.

    一般需要实现前三条要求:

    -   程序中**不含有语法错误**;
    -   程序对**几组输入数据**能够得出满足要求的结果;
    -   程序对于**精心选择的, 典型和苛刻且带有刁难性**的几组输入数据都可以得出满足要求的结果;
    -   程序对于**一切合法的输入数据**都可以获得满足要求的结果.

-   可读性

    -   算法主要为了方便人的交流阅读;
    -   晦涩的算法会隐藏很多错误;

-   健壮性

    -   指当**输入非法数据**的时候, 算法做出恰当的反应和处理.
    -   处理出错的方法, 不因该是中断程序执行, 而是返回一个表示错误或错误性的值, 交付上级处理.

-   高效性

    -   要求花费尽量少的时间和尽量低的存储.

## 1.4. 算法和算法分析(2)

一个好的算法首先要满足正确性, 健壮性, 可读性, 在几个方面都满足的条件下, 主要考虑算法的效率, 通过算法的效率高低判断不同算法的优劣程度.

算法的效率主要考虑以下两个方面:

-   时间效率: 指算法所**消耗的时间**.
-   空间效率: 指算法在执行过程中**耗费的的存储空间**.

>   时间效率和空间效率有时候是矛盾的. 需要根据实际情况平衡考虑.

### 度量算法的时间效率

算法的时间效率可以用依据该算法编制的程序**在计算机上执行所消耗的时间**来度量.

两种度量方法:

-   事后统计

    编号程序后实际运行程序, 测算其时间和空间开销.

    缺陷: 必须转化成程序; 实验结果依赖于计算机软硬件等环境因素, 从而可能掩盖算法本身的优劣.

-   事前分析 ( 使用较多 )

    对算法所消耗资源的一种估算的方式.

### * 事前分析方法

核心思想是: 一个算法运行时间指的是一个算法在计算机上运行所耗费的时间可以等于计算机执行一种简单的操作所需的**时间**与算法中进行简单操作的**次数乘积**.

**算法的运行时间 = 一个简单操作所需的时间 * 简单操作次数.** 

也即算法中每条语句执行时间之和:

**运行时间 = Σ(每条语句的执行次数 * 该语句执行一次所需时间)**

其中, 每条语句执行次数也称为"语句的频度".

从而:

**运行时间 = Σ(每条语句的频度* 该语句执行一次所需时间)** 

>   每条语句执行一次所需的时间是随机器不同而不同的, 取决于机器的指令性能, 速度, 以及编译的代码质量. 由机器本身硬件环境决定, 与算法无关.
>
>   所以可以假设每条语句执行所需的时间都是**单位时间**, 这样对算法的运行时间的讨论就成了对所有语句频度之和的计算.

### * 算法时间复杂度的渐近表示法

为了比较不同算法的时间效率, 我们仅仅比较他们的数量级.

若有某个辅助函数fn), 使得当n趋近于无穷夫时, `T(n) / f(n)`的极限值为不等于零的常数, 则称f(n)是T(n)的同数量级函数. 记作`T(n) = O( f(n) )`, 称 `O( f(n) )` 为算法的**渐进时间复杂度**(O是教量级的符号)，简称**时间复杂度**。

一般情况下, 不必计算所有操作的执行次数, 而只考虑算法中基本操作的执行次数, 他是问题规模n的某个函数, 用T(n)表示.

---

算法中**基本语句重复执行的次数**是**问题规模n**的某个函数f(n), 算法的时间量度记作: `T(n) = O( f(n) )` 

>   他表示随着n的增大, 算法执行的时间的增长率和f(n)的增长率相同, 称为**渐进时间复杂度**.

#### 如何找到基本语句?

-   算法中重复执行次数和算法的执行时间成正比的语句;
-   对算法运行时间的贡献最大;
-   执行次数最多.

#### 如何计算问题规模n?

n越大算法的执行时间越长.

-   排序: n是记录数
-   矩阵: n是矩阵的阶数
-   多项式: n是多项式的项数
-   集合: n是元素个数
-   数: n是树的节点数
-   图: n是图的顶点数或者边数.

## 1.4. 算法和算法分析(3)

### 分析算法时间复杂度的基本方法

#### 定理1.1

![image-20230107180803512](./第一章笔记.assets/image-20230107180803512.png)

说明: 就是可以抓大头, 当有一个项的指数最大时, 则可以不考虑低次项, 并且可以把最高次项的系数去掉.

这样得到的最高次项就是时间复杂度的数量级.

#### 计算时间复杂度的方式

1.   找出语句频度最大的那条语句作为基本语句;
2.   计算基本语句的频度得到问题规模n的某个函数f(n);
3.   取其数量级用符号O表示.

**时间复杂度是由嵌套最深层语句的频度决定的**.

### 常见的时间复杂度计算

#### for循环嵌套计算

简单的算法: 有几层for循环就是n的几次方.

例题(计算时间复杂度):

<img src="./第一章笔记.assets/image-20230107190633336.png" alt="image-20230107190633336" style="zoom:80%;" />

答案是n^3

#### while循环复杂度计算

简单的算法: lg n (n是对数) (就是以10为底n的对数)

<img src="./第一章笔记.assets/image-20230107190830094.png" alt="image-20230107190830094" style="zoom:80%;" />

答案是log以2为底n的对数.

## 1.4. 算法与算法分析(4)

### 算法的时间复杂度

 有时候, 算法中基本操作重复的次数还会随**输入数据集**的不同而不同.*比如使用顺序查找的方式查找数组中的元素.的时候* 

所以在算法分析的时候, 需要考虑最坏时间复杂度和平均时间复杂度.

-   最坏时间复杂度: 指在最坏的情况下, 算法的时间复杂度;
-   平均时间复杂度: 指在所有可能输入实例在等概率出现的情况下, 算法的期望运行时间;
-   最好时间复杂度: 指在最好的情况下, 算法的时间复杂度;

一般**总是考虑在最坏情况下的时间复杂度**, 以保证算法的运行时间不会比他更长.

### 复杂的时间复杂度计算

对于复杂的算法, 可以将其分为几个易于估算的部分, 然后用大O**加法法则和乘法法则**, 计算算法的时间复杂度.

-   加法规则

    T(n) = T1(n) + T2(n) = O(f(n)) + O(g(n)) = O(max( f(n), g(n) ))

    取两个复杂度中数量级大的那个

-   乘法规则

    T(n) = T1(n) * T2(n) = O(f(n)) * O(g(n)) = O(f(n) * g(n))

>   总结: 加法取大, 乘法取积.

### 算法时间效率的比较

-   当n取的很大的时候, 指数时间算法和多项式事件算法在所需时间上差距十分悬殊.

    ![image-20230108202312874](./第一章笔记.assets/image-20230108202312874.png)

    按照时间复杂度数量级递增的顺序排列:

    ![image-20230108202924698](./第一章笔记.assets/image-20230108202924698.png)

    简称: 常对幂指阶

    所以在设计算法的时候, 尽量设计复杂度底的算法.

### 渐进空间复杂度

-   空间复杂度: 算法所需存储空间的度量.

    记作 S(n) = O(f(n))

    其中n是问题的规模(或者大小)

-   算法要占据的空间包括:

    -   算法本身占据的空间, 包括输入输出语句, 指令, 常数, 变量等.
    -   算法要使用的**辅助空间**.

